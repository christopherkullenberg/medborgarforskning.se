#
# File Name: nginx.conf
# Description: configure nginx within the docker container. Setup as a reverse proxy.
# Author: Jonathan Brier & Christopher Kullenberg
# Inspired by https://github.com/benoitc/gunicorn/blob/master/examples/nginx.conf
#
# nginx 1.17.7, intermediate config, OpenSSL 1.1.1d
# Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9
# For configuration recommendations and generator - https://wiki.mozilla.org/Security/Server_Side_TLS
# Check SSL configuration against best practices at https://observatory.mozilla.org/


### Documentation: https://nginx.org/en/docs/ngx_core_module.html#worker_processes
worker_processes 1; #Default value is "worker_processes 1;", but try auto or the to number of cpus to start

user nobody nogroup;

### set the level of logging - [ debug | info | notice | warn | error | crit ]
# error_log  /var/log/nginx/error.log warn;

pid /var/run/nginx.pid;

events {
  worker_connections 1024; # increase if you have lots of clients
  accept_mutex off; # set to 'on' if nginx worker_processes > 1
}

http {
  include mime.types;
  default_type text/html;

  upstream django_server {
    ### Configuring a way for more than one server hosting the app
    server djangoapp-app:8000 fail_timeout=0;

  ### for UNIX domain socket setups
  #server unix:/tmp/gunicorn.sock fail_timeout=0;
  }

### Drop any ports we aren't using
#  server {
    ### if no Host match, close the connection to prevent host spoofing
#    listen 80 default_server;
#    listen 443;
#    return 444; # don't return response for anything, but the ports listed
#  }

### Redirect all incoming http requests to the same site and URI on https, using nginx - enable after certificate is installed
#server {
#  listen 80 default_server; # ipv4 listening for upgrade to https redirect
#  listen [::]:80 default_server; # ipv6 listening for upgrade to https redirect
#
#  return 301 https://$host$request_uri;
#}


### Specific configuration of Nginx for serving the docker based ArcsSystem app
server {
     ##### Begin Transitional Configuration ##### port opened to listen, set default
     # listen 80 deferred; # enable if a default server is set in another server block {}
     listen 80 default_server; # ipv4 listen # TODO remove once ssl certificate is included below
     ##### End Transitional Configuration ##### TODO Delete config section once ssl config is complete


     ##### Begin SSL configuration ##### enable this block after server has an ssl certificate
     ## listen 443 ssl http2; # TODO only enable after django supports http2 until then use without "http2"
     ## listen [::]:443 ssl http2; # TODO only enable after django supports http2 until then use without "http2"
     # listen 443 ssl;
     # listen [::]:443 ssl;

     # ssl_certificate /etc/letsencrypt/live/medborgarforskning/fullchain.pem; # /path/to/signed_cert_plus_intermediates
     # ssl_certificate_key /etc/letsencrypt/live/medborgarforskning/privkey.pem; # /path/to/private_key;

     # ssl_session_timeout 1d;
     # ssl_session_cache shared:MozSSL:10m;  # about 40000 sessions
     # ssl_session_tickets off;

    ### modern configuration
    # ssl_protocols TLSv1.2 TLSv1.3;
    # ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    # ssl_prefer_server_ciphers on; # modern suggests off if you only use TLSv1.3

    ### HSTS (ngx_http_headers_module is required) (63072000 seconds)
    # add_header Strict-Transport-Security "max-age=63072000" always; #

    ### OCSP stapling
    # ssl_stapling on;
    # ssl_stapling_verify on;

    ### verify chain of trust of OCSP response using Root CA and Intermediate certs
    # ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates;

    ### replace with the IP address of your resolver ie the nameservers
    # resolver 127.0.0.1;

    ### enable for letsencrypt wildcard deployment
    # include /etc/letsencrypt/options-ssl-nginx.conf; # TODO implement letsencrypt wildcard container
    ##### End SSL configuration #####

    ##### Begin application configuration #####
    ### set the names that this server will handle (one per line for readability)
    server_name localhost; # TODO disable once certificate and name setting is completed and for production
    server_name arcs.local; # Insert the naked domain name
    server_name www.arcs.local; # Insert the www subdomain variant of your domain name (because people still type it manually and we want to handle this)
    server_name *.arcs.local; # Insert a wildcard variant for a catch all other subdomains not listed.

    charset utf-8;
    root /var/www/arcs_collected_static/; #sets the root of your files on the server

    ### max upload size
    client_max_body_size 75M;   # adjust to taste

    # deny scripts inside writable directories
    location ~* /(static|images|cache|media|logs|tmp)/.*.(php|pl|py|jsp|asp|sh|cgi)$ {
      return 403;
      error_page 403 /403_error.html;
    }

    ### prevent image hotlinking from 3rd parties # TODO reenable after static content testing completes
#    location ~ .(webp|png|gif|jpe?g)$ {
#      valid_referers none blocked medborgarforskning.se; # place valid domain name. Recommend one per line for readability.
#      valid_referers none blocked *.medborgarforskning.se; # place valid subdomains. Recommend one per line for readability.
#      if ($invalid_referer) {
#        return   403;
#      }
#    }

    ### set Nginx to handle the site design static files to offload from python app
    location /static/ { # scripts, images, etc for site design - working don't touch
      alias /var/www/arcs_collected_static/static/;
    }

    ### set Nginx to handle the user uploaded static files to offload from python app
    location /media/ { # host static files from user side
      alias /var/www/arcs_collected_static/media/;
    }

    location / {
      ### checks for static file, if not found proxy to app
      try_files $uri @proxy_to_app;
    }

    ### Reverse proxy the Django app requests
    location @proxy_to_app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Forwarded-Host $server_name;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header Host $http_host;

      ### we don't want nginx trying to do something clever with
      ### redirects, we set the Host: header above already.
      proxy_redirect off;
      proxy_pass http://django_server;
    }

    #error_log /etc/nginx/error_log.log;
    #access_log /etc/nginx/access_log.log;

    #error_page 500 502 503 504 /500.html; # TODO create and add 500.html
    #location = /500.html {
    #}
  }
}
